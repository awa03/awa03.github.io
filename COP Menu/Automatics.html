<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Automatics</title>
</head>
<body style="background-color:black";>
<style>
  button {
    transition: transform .1s ease-in-out;
  }
  button:hover {
    transform: scale(.9);
  }
  h1 {
    font-family: Arial, sans-serif;
    color: darkred;
    text-align: Left;
  }
  h2 {
    font-family: Arial, sans-serif;
    color: red;
    text-align: Left;
  }
  h3 {
    font-family: Arial, sans-serif;
    color: red;
    text-align: Left;
  }
  h4 {
    font: italic;
    font-family: Arial, sans-serif;
    color: orangered;
    text-align: Left;

  }
  p {
    padding-right: 30px;
    padding-bottom: 20px;
    font-family: Arial, sans-serif;
    color: whitesmoke;
    text-align: left;
  }
  h4 {

    padding-right: 30px;
    padding-bottom: 40px;
    padding-left: 40px;
    font-family: Arial, sans-serif;
    color: whitesmoke;
  }
  .highlight {
    color: #fafad2;
  }
  .highlight_red {
    color: red;
    font: bold;
  }
  button {
    background: darkred;
    color: whitesmoke;
    height: 70px;
    width: 150px;
  }
</style>
<body>
  <h1>
    Automatics, Copy Constructor, Assignment Operator
  </h1>
  <p>
    Automatics do not need to be explicitly defined by one class, a default version is built by the compiler
    <br><br>
    The automatic versions of the constructor and destructor don't do anything, but they will be there if you do not build them.
    (The constructor you get is the "default constructor" -- no parameters -- and this is automatically built if you don't define
    any constructor besides the copy constructor). The automatic versions of the Copy Constructor and the Assignment operator overload
    are similar to each other, and their default versions are always built in a standard way.
  </p>
  <h3>
    Examples Include
  </h3>
  <p>
    - Constructor<br>
    - Destuctor<br>
    - Copy Constructor <br>
    - Assignment operator =<br>
    <br>
    <i>
    The assignment operator was used by default within the unlimited int storage assignment. j = s + j worked even though we did not
      build an assignment operator.
    </i>
  </p>
  <h3>
    Copy Constructors:
  </h3>
  <p>
    A copy constructor is considered a constructor, it has the same name as the class and no return type is specified.
    It is invoked when there is an attempt to copy the existing object.
  </p>
  <h4>
    - An object is defined to have the value of another object of the same type<br>
    - An object is passed by value into a function<br>
    - An object is returned (by value) from a function<br>
  </h4>
  <p>
    <text class="highlight_red">
      Example:
    </text>
    <br>
    Fraction f1, f2(3,4);    // declaration of two fractions<br>
    Fraction f3 = f2;        // declaration of f3 being initialized as a copy of f2<br>
  </p>
  <h3>
    Declaring and Defining
  </h3>
  <p>
    a copy constructor always has one parameter, which is of the same type as the class itself.
    It is always passed by reference, as well (it has to be -- since to pass by value, we must invoke a copy constructor,
    and this is what we are defining!)
    <br><br>
    Format:    className(const className &);
    <br><br>
    Const is not required, however it is commonly used because we are only making a copy of the original object and not
    envoking any change on the member data within. We used these within the course assignments, as seen below.
    <br><br>
    <text class="highlight_red">
      Course Examples:
    </text><br>
    Fraction(const Fraction & f);<br>
    Timer(const Timer & t);<br>
    Directory(const Directory & d);<br>
    Store(const Store & s);<br>
  </p>
  <h3>
    Shallow Vs. Deep Copies
  </h3>
  <p>
    The default version of the copy constructor (created by the compiler) makes what is known as a
    <text class="highlight">shallow copy</text>
    . This simply means that the object is copied exactly as is -- each member data value is copied exactly over to the
    corresponding member data location in the new object.  This is sufficient for many cases, but not for ALL cases.
    <br>
    If we look at the example of a phone book. The current size, max size, and other member data were stored outside of
    the actual object. A deep copy allows us to avoid problems of the data going out of scope. So when a shallow copy is not
    sufficent a deep copy may need to be made. Here is an example of a copy constructor.<br><br>
    Directory::Directory(const Directory & d)<br>
    // copies object 'd' into the new object being created (this one)<br>
    {<br>
    // copy the static variables normally<br>
    <br>
    maxsize = d.maxsize;<br>
    currentsize = d.currentsize;<br>
    // create a new dynamic array for the new object's pointer<br>
    <br>
    entryList = new Entry[d.maxsize];<br>
    // copy the dynamic data<br>
    <br>
    for (int i = 0; i < currentsize; i++)<br>
    entryList[i] = d.entryList[i];<br>
    }<br>
  </p>
  <h3>
    Assignment Operator
  </h3>
  <p>
    The assignment operator is similar to the copy constructor, it is called when an object is assigned to another.
    The assignment operator, like the copy constructor makes a shallow copy of the object. If we need to create a deep
    copy for assignments, then it should be created in an overloaded function
    <br><br>
    The copy constructor creates a brand-new object as a copy of the original one, where as an assignment operator sets an
    existing objects state to that of another object. This may mean that copy constructors that require dynamic memory allocation
    may need to clean up old dynamic space before it is alloted.<br><br>
    a = b = c = 4;<br>
    The first operation is (c = 4), and this operation returns c (which now has value 4), so that the result can be used as an operand
    in the next assignment (b = 4). The calling object should be returned by reference when overloading = for objects. To return the object, we need to be able to refer to an object from inside the object itself.
  </p>
  <h3>
    This Damn Pointer
  </h3>
  <p>
    <text class="highlight">This</text> is a keyword that allows the member function to have access to its own address. In an assignment
    operator this may be useful because you can return the target object by pointer refrence. (*this)
  </p>

</body>
<div>
<br><br><br><br>
<center><button onclick="window.location.href = 'index.html';">Notes Menu</button>
  <button onclick="window.location.href = 'menu.html';">COP Notes</button></center>
</div>
<br><br><br><br><br>
</html>